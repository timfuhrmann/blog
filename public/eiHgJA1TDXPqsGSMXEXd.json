{
  "history": [
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "gradient",
      "speed": 0.16,
      "mouseMomentum": 1,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;const vec3 uColors[6] = vec3[]( vec3(0.000000, 0.000000, 0.000000), vec3(0.160784, 0.160784, 0.160784), vec3(0.392157, 0.392157, 0.392157), vec3(0.615686, 0.615686, 0.615686), vec3(0.815686, 0.815686, 0.815686), vec3(1.000000, 1.000000, 1.000000) );uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0+0.025*a*(1.0-a); return kLMStoCONE*(lms*lms*lms); }vec3 getGradientColor(float position) { for (int i = 0; i < 6; i++) { float colorPosition = float(i) / float(6); float nextColorPosition = float(i + 1) / float(6); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(uColors[i]); vec3 linEnd = linear_from_srgb(uColors[i + 1]); vec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor); return srgb_from_linear(mixedLin); } } return srgb_from_linear(uColors[6-1]); }vec3 Tonemap_ACES(vec3 x) { const float a = 2.51; const float b = 0.03; const float c = 2.43; const float d = 0.59; const float e = 0.14; return (x * (a * x + b)) / (x * (c * x + d) + e); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5144164980252651, 0.4720831574736841) + mix(vec2(0), (uMousePos-0.5), 1.00); uv -= pos; uv /= (0.91*2.); uv = rotate(uv, (0.56 - 0.5) * 2. * 3.14159265);vec4 color = vec4(0,0,0,1);float position; if(6 == 1) { color.rgb = uColors[0]; } else if (0 == 0) { position = (uv.x+0.5);} else if (0 == 1) { position = length(uv); } else if (0 == 2) { float angle = atan(uv.y, uv.x); float normalizedAngle = angle / (2.0 * 3.14159265359) + 0.5; float doubledAngle = 2.0 * normalizedAngle; doubledAngle = doubledAngle > 1. ? 2.0 - doubledAngle : doubledAngle; position = clamp(doubledAngle, 0.0, 1.0); } else if (0 == 3) { } if(6 > 1) { position -= (uTime*0.01 + 0.22); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? fract(-position) : fract(position); animatedPos = reverse ? animatedPos - 1./float(6) : animatedPos - 1./float(6);color.rgb = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; color.rgb += dither; }fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": { "depth": false }
    },
    {
      "local": {
        "id": "320bf5fd-594d-4d2c-b46c-d28fc528ed8f",
        "canvas": {},
        "ctx": {}
      },
      "visible": true,
      "locked": false,
      "aspectRatio": 0.5625,
      "isElement": true,
      "opacity": 1,
      "displace": 0,
      "trackMouse": 0,
      "mouseMomentum": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "layerType": "shape",
      "borderRadius": 0,
      "coords": [
        [0, 0],
        [-352, 0],
        [-352, 372],
        [0, 372]
      ],
      "effects": [],
      "fill": ["#EEEEEE"],
      "gradientAngle": 0,
      "gradientType": "linear",
      "mask": 0,
      "rotation": 0,
      "translateX": 361,
      "translateY": 65,
      "type": "circle",
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uniform int uSampleBg;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.00); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); uv = perspectiveUV(uv) - pos; vec4 color = texture(uTexture, uv); vec4 background = uSampleBg == 1 ? texture(uBgTexture, vTextureCoord) : vec4(0);color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ]
    },
    {
      "local": {
        "id": "2fa833fd-9e8a-48fe-b752-fdcc7bfbdb4d",
        "canvas": {},
        "ctx": {}
      },
      "visible": true,
      "locked": false,
      "aspectRatio": 0.5625,
      "isElement": true,
      "opacity": 1,
      "displace": 0,
      "trackMouse": 0,
      "mouseMomentum": 0,
      "blendMode": "OVERLAY",
      "bgDisplace": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "layerType": "shape",
      "borderRadius": 0,
      "coords": [
        [0, 0],
        [-352, 0],
        [-352, 372],
        [0, 372]
      ],
      "effects": [],
      "fill": ["#FFFFFF"],
      "gradientAngle": 0,
      "gradientType": "linear",
      "mask": 0,
      "rotation": 0,
      "translateX": 401,
      "translateY": 280,
      "type": "circle",
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uMaskTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z))); }const float STEPS = 24.0; const float PI = 3.1415926;vec3 refrakt(vec3 eyeVector, vec3 normal, float iorRatio) { float dotProduct = dot(eyeVector, normal); float k = 1.0 - iorRatio * iorRatio * (1.0 - dotProduct * dotProduct); if (k < 0.0) { return reflect(eyeVector, normal); } else { return iorRatio * eyeVector - (iorRatio * dotProduct + sqrt(k)) * normal; } }vec4 displacement (vec2 st, vec4 bg, vec4 color) { if(0.00 == 1.0) { vec2 refraction = refrakt(vec3(vTextureCoord, 0.5), color.rgb, 0.00-0.5).xy; vec2 displaced = vTextureCoord + mix(vec2(0), refraction * 0.1, 0.00); vec4 bgDisp = texture(uBgTexture, displaced); bgDisp.rgb = bgDisp.rgb; return bgDisp * color.a; } else { vec2 normal = vec2(bg.r * 2.0 - 1.0, bg.g * 2.0 - 1.0) * 0.1; if(0.00 == 1.) { return texture(uMaskTexture, st + normal * 0.00) * texture(uTexture, st + normal * 0.00).a; } else { return texture(uTexture, st + normal * 0.00); } } }vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.00); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); uv = perspectiveUV(uv) - pos; vec4 maskColor = texture(uMaskTexture, vTextureCoord); vec4 background = uSampleBg == 1 ? texture(uBgTexture, vTextureCoord) : vec4(0); vec4 color = texture(uTexture, uv);if (0.00 == 1.) { color = maskColor * color.a; }if (0.00 > 0.) { if(0.00 == 1.) { color = displacement(uv, background, maskColor); } else { color = displacement(uv, background, color); } }if (5 > 0) { color = color/(color.a + 0.00000001); color.rgb = blend(5, color.rgb, background.rgb); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ]
    },
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "blur",
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(-0.7116238124931225, 0.3668341708542714) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.; float amount = (3.62 * amt) * ease(0, mix(inner, outer, 0.50)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(-0.7116238124931225, 0.3668341708542714) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 3.62 * ease(0, mix(inner, outer, 0.50)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.50, 1. - 0.50)); } return color/float(kernelSize); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 0 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); if(0 == 0) { color = GaussianBlur(uTexture, uv, direction); } else { color = BoxBlur(uTexture, uv, direction); } if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}",
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(-0.7116238124931225, 0.3668341708542714) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.; float amount = (3.62 * amt) * ease(0, mix(inner, outer, 0.50)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(-0.7116238124931225, 0.3668341708542714) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 3.62 * ease(0, mix(inner, outer, 0.50)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.50, 1. - 0.50)); } return color/float(kernelSize); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 1 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); if(0 == 0) { color = GaussianBlur(uTexture, uv, direction); } else { color = BoxBlur(uTexture, uv, direction); } if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}",
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(-0.7116238124931225, 0.3668341708542714) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.; float amount = (3.62 * amt) * ease(0, mix(inner, outer, 0.50)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(-0.7116238124931225, 0.3668341708542714) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 3.62 * ease(0, mix(inner, outer, 0.50)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.50, 1. - 0.50)); } return color/float(kernelSize); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 2 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); if(0 == 0) { color = GaussianBlur(uTexture, uv, direction); } else { color = BoxBlur(uTexture, uv, direction); } if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}",
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(-0.7116238124931225, 0.3668341708542714) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.; float amount = (3.62 * amt) * ease(0, mix(inner, outer, 0.50)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(-0.7116238124931225, 0.3668341708542714) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 3.62 * ease(0, mix(inner, outer, 0.50)); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount/144.; color += texture(tex, uv + vec2(x) * direction * vec2(0.50, 1. - 0.50)); } return color/float(kernelSize); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 3 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); if(0 == 0) { color = GaussianBlur(uTexture, uv, direction); } else { color = BoxBlur(uTexture, uv, direction); } if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {
        "downSample": true,
        "depth": false,
        "passes": [
          { "prop": "vertical", "value": 1, "downSample": true },
          { "prop": "vertical", "value": 2, "downSample": true },
          { "prop": "vertical", "value": 3, "downSample": true }
        ]
      }
    },
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "flowField",
      "speed": 0.25,
      "mouseMomentum": 0,
      "texture": false,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }float hash31(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yzx + 19.19); return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z); } vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031,.11369,.13787)); p3 += dot(p3, p3.yxz+19.19); return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x)); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi; vec3 w = pf * pf * (3.0 - 2.0 * pf); return mix( mix( mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))), w.x), mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))), w.x), w.z), mix( mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))), w.x), mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))), w.x), w.z), w.y); }const float MAX_ITERATIONS = 16.; vec2 flow (in vec2 st) { float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(1.0109794715670812, 0.6256281407035174) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = vec2(1.0109794715670812, 0.6256281407035174); float dist = ease(0, max(0.,1.-distance(st * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));float sprd = (0.38 + 0.01) / ((aspectRatio + 1.) / 2.); float amt = 1.81 * 0.01 * dist; if(amt <= 0.) { return st; }for (float i = 0.; i < MAX_ITERATIONS; i++) { vec2 scaled = (st-0.5) * vec2(aspectRatio, 1) + (1. - pos); float perlin = perlin_noise(vec3((scaled-0.5) * (5. * sprd), 32.67*5. + uTime/60.))-0.5; float ang = (perlin * (360. * (0.15 * 6.))) * 3.1415926 / 180.; st += vec2(cos(ang), sin(ang)) * amt; st = clamp(st, 0., 1.); }return st; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, mix(uv, flow(uv), 1.00)); if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false }
    },
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "grain",
      "speed": 0.2,
      "texture": false,
      "animating": true,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform float uNoise; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z))); } const float PHI = 1.61803398874989484820459; float gold_noise(in vec2 xy, in float seed) { return fract(tan(distance(xy*PHI, xy)*seed)*xy.x); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); vec2 st = uv; vec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(1 == 1) { grainRGB = vec3( gold_noise(st, delta + 1.), gold_noise(st, delta + 2.), gold_noise(st, delta + 3.) ); } else { grainRGB = vec3(gold_noise(st, delta + 1.)); } if(5 > 0) { color.rgb = mix(color.rgb, blend(5, grainRGB, color.rgb), 0.11); } if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false }
    },
    {
      "visible": true,
      "aspectRatio": 1,
      "layerType": "effect",
      "type": "gradientMap",
      "speed": 0.5,
      "texture": false,
      "animating": false,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution; const vec3 uColors[2] = vec3[]( vec3(0.000000, 0.000000, 0.000000), vec3(1.000000, 1.000000, 1.000000) ); uniform float uTime;float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0 + 0.02 * a * (1.0 - a); return kLMStoCONE*(lms*lms*lms); }vec3 getGradientColor(float position) { for (int i = 0; i < 2; i++) { float colorPosition = float(i) / float(2); float nextColorPosition = float(i + 1) / float(2); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(uColors[i]); vec3 linEnd = linear_from_srgb(uColors[i + 1]); vec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor); return srgb_from_linear(mixedLin); } } return srgb_from_linear(uColors[2-1]); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float position = smoothstep(0., 1., color.r) * (0.50 * 2.); float posOffset = (dot(vec2(0.5, 0.5).x, vec2(0.5, 0.5).y) + 0.00 + 0.0001) * 2.; position -= (uTime*0.01 + posOffset); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? fract(-position) : fract(position); animatedPos = reverse ? animatedPos - 1./float(2) : animatedPos - 1./float(2); animatedPos = clamp(animatedPos, 0. - 1./float(2), 1.0);color.rgb = (getGradientColor(animatedPos)); float dither = rand(gl_FragCoord.xy) * 0.005; color.rgb += dither;fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": { "depth": false }
    }
  ],
  "options": { "name": "Flow gradient", "fps": 60, "dpi": 2, "scale": 1 },
  "version": "1.2.5"
}
